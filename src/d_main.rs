use crate::version;

use crate::cmd_args;

use crate::console::Cons;
use crate::m_misc::Misc;
use crate::m_argv::MArgv;
use crate::g_game::Game;
use crate::sounds::Sounds;
use crate::dehacked::Dehacked;
use crate::z_zone::Zone;
use crate::command::Command;
use crate::screen::Screen;

// For SDL interface
use crate::sdl::i_main::IMain;
use crate::sdl::i_system::ISystem;
use crate::sdl::i_video::IVideo;
use crate::sdl::mixer_sound::MixerSound;
use crate::sdl::sdlmain::SdlMain;

pub struct DMain {
	// Version numbers for netplay 
	pub version: i32,
	pub subversion: i32,

	// platform independant focus loss
	pub window_notinfocus: bool, // UINT8

	///// DEMO LOOP
	pub startupwadfiles: Vec<char>, //startupwadfiles[MAX_WADFILES];
	pub startuppwads: Vec<char>, 	//*startuppwads[MAX_WADFILES];

	// started game with '-devparm'
	pub devparm: bool,
	pub singletics: bool,
	pub lastdraw: bool,

	// TODO: ACCEPTS a postimg_t
	//pub postimgtype: postimg_t,
	pub postimgparam: i32,
	//pub postimgtype2: postimg_t,
	pub postimgparam2: i32,

	// These variables are in effect
	// whether the respective sound system is disabled
	// or they're init'ed, but the player just toggled them
	pub midi_disabled: bool,
	pub sound_disabled: bool,
	pub digital_disabled: bool,

	pub advancedemo: bool,
	//ifdef DEBUGFILE
	pub debugload: i32,
	//endif

	pub numskincolors: u16, //UINT16
	// TODO: ACCEPTS a menucolor_t
	//pub menucolorhead: menucolor_t,
	//pub menucolortail: menucolor_t,

	pub savegamename: std::string::String,
	pub liveeventbackup: std::string::String,

	pub srb2home: std::string::String,
	pub srb2path: std::string::String,
	pub usehome: bool,
	pub pandf: std::string::String,
	pub addonsdir: Vec<char>, //addonsdir[MAX_WADPATH];
	
	//
	// EVENT HANDLING
	//
	// Events are asynchronous inputs generally generated by the game user.
	// Events can be discarded if no responder claims them
	// referenced from i_system.c for I_GetKey()
	// TODO: ACCEPTS a events_t
	//pub events: events_t, //events[MAXEVENTS];
	pub eventhead: i32,
	pub eventtail: i32,

	pub dedicated: bool,

	// modifier keys
	// Now handled in I_OsPolling
	pub shiftdown: u8, 	// 0x1 left, 0x2 right //UINT8
	pub ctrldown: u8, 	// 0x1 left, 0x2 right //UINT8
	pub altdown: u8, 	// 0x1 left, 0x2 right //UINT8
	pub capslock: bool,


	// wipegamestate can be set to -1 to force a wipe on the next draw
	// added comment : there is a wipe eatch change of the gamestate
	// TODO: ACCEPTS a gamestate_t
	//pub wipegamestate: gamestate_t,
	// -1: Default; 0-n: Wipe index; INT16_MAX: do not wipe
	pub wipetypepre: i16,
	pub wipetypepost: i16,

	// TODO: ACCEPTS a tic_t
	//pub rendergame: tic_t,
}
impl DMain {
	pub fn new() -> Self {
		DMain {
			version: 0, 	// todo: calculate
			subversion: 0,	// todo: calculate
			window_notinfocus: false,
			startupwadfiles: Vec::new(),
			startuppwads: Vec::new(),
			devparm: false, // todo: calculate
			singletics: false,
			lastdraw: false,
			postimgparam: 0,
			postimgparam2: 0,
			midi_disabled: false,
			sound_disabled: false,
			digital_disabled: false,
			advancedemo: false,
			debugload: 0,
			numskincolors: 0,
			savegamename: std::string::String::from(""),
			liveeventbackup: std::string::String::from(""),
			srb2home: std::string::String::from("."),
			srb2path: std::string::String::from("."),
			usehome: true,
			pandf: std::string::String::from("%s%s")/*%sPATHSEP%s*/,
			addonsdir: Vec::new(),
			eventhead: 0,
			eventtail: 0,
			dedicated: false,
			shiftdown: 0,
			ctrldown: 0,
			altdown: 0,
			capslock: false,
			wipetypepre: -1,
			wipetypepost: -1,
		}
	}

	pub fn convert_version_nums(&mut self) {
		let _major: i32;
		let _minor: i32;

		//sscanf(SRB2VERSION, "%d.%d.%d", &major, &minor, &SUBVERSION);

		// TODO: use sscanf esque method to acquire major and minor versions
		// major
		self.version = version::SRB2VERSION.chars().nth(0).unwrap().to_digit(10).unwrap() as i32;
		// minor
		self.subversion = version::SRB2VERSION.chars().nth(2).unwrap().to_digit(10).unwrap() as i32;
	}

	// Do preparations
	pub fn srb2_main(&mut self, 
		_console: &Cons,
		m_misc: &Misc,
		m_argv: &mut MArgv,
		g_game: &mut Game,
		sounds: &Sounds,
		dehacked: &Dehacked,
		i_system: &mut ISystem,
		i_video: &mut IVideo<'static>,
		// SDL
		sdl_context: &mut Option<sdl2::Sdl>,
		video_subsystem: &mut Option<sdl2::VideoSubsystem>,
		window_canvas: &mut Option<sdl2::render::WindowCanvas>,
		event_pump: &mut Option<sdl2::EventPump>,

		mixer_sound: &MixerSound,
		i_main: &mut IMain,
		z_zone: &Zone,
		command: &mut Command,
		sdlmain: &mut SdlMain,
		screen: &Screen
		) {
		let _p: i32;
		let _pstartmap: i32 = 1;
		let _autostart: bool = false;

		// Break version string into version numbers for netplay
		self.convert_version_nums();

		// todo: something is probably wrong about this?
		// Print GPL notice for our console users (Linux)
		cons_printf!(
		"\n\nSonic Robo Blast 2\n",
		"Copyright (C) 1998-2020 by Sonic Team Junior\n\n",
		"This program comes with ABSOLUTELY NO WARRANTY.\n\n",
		"This is free software, and you are welcome to redistribute it\n",
		"and/or modify it under the terms of the GNU General Public License\n",
		"as published by the Free Software Foundation; either version 2 of\n",
		"the License, or (at your option) any later version.\n",
		"See the 'LICENSE.txt' file for details.\n\n",
		"Sonic the Hedgehog and related characters are trademarks of SEGA.\n",
		"We do not claim ownership of SEGA's intellectual property used\n",
		"in this program.\n\n");

		// initialise locale code
		m_misc.m_startup_locale();

		// get parameters from a response file (eg: srb2 @parms.txt)
		m_argv.m_find_response_file();

		// MAINCFG is now taken care of where "OBJCTCFG" is handled
		g_game.g_load_game_settings(sounds);

		// Test Dehacked Lists
		dehacked.deh_check();

		// Netgame URL special case: change working dir to EXE folder.
		//ChangeDirForUrlHandler()

		// identify the main IWAD file to use
		//self.identify_version();

		self.devparm = m_argv.m_check_parm(cmd_args::DEBUG) != 0;
		self.dedicated = m_argv.m_check_parm(cmd_args::DEDICATED) != 0;

		if self.devparm {
			//CONS_Printf(M_GetText("Development mode ON.\n"));
			cons_printf!("Development mode ON.\n");
		}

		// default savegame
		//strcpy(savegamename, SAVEGAMENAME"%u.ssg");
		//strcpy(liveeventbackup, "live"SAVEGAMENAME".bkp"); // intentionally not ending with .ssg

		// wat
		// {
			let userhome: String = self.d_home(m_argv);

			if userhome == "".to_string() {
				// unfortunately variadic functions are not a thing in Rust
				// therefore we'll use an array instead
				i_system.i_error(&["Please set $HOME to your home directory\n"], &i_video, &mixer_sound, i_main);
				/*
				if self.dedicated {
					//snprintf(configfile, sizeof configfile, "d"CONFIGFILENAME);
				else {
					//snprintf(configfile, sizeof configfile, CONFIGFILENAME);
				}*/
			} else {
				//use user specific config file
				if self.dedicated {
					cons_printf!(self.srb2home);//snprintf(configfile, sizeof configfile, "%s" PATHSEP "d"CONFIGFILENAME, srb2home);
				} else {
					cons_printf!(self.srb2home);//snprintf(configfile, sizeof configfile, "%s" PATHSEP CONFIGFILENAME, srb2home);
				}
			
			/*
			// can't use sprintf since there is %u in savegamename
			strcatbf(savegamename, srb2home, PATHSEP);
			strcatbf(liveeventbackup, srb2home, PATHSEP);

			snprintf(luafiledir, sizeof luafiledir, "%s" PATHSEP "luafiles", srb2home);

			snprintf(srb2home, sizeof srb2home, "%s", userhome);
			snprintf(downloaddir, sizeof downloaddir, "%s", userhome);
			if (dedicated)
				snprintf(configfile, sizeof configfile, "%s" PATHSEP "d"CONFIGFILENAME, userhome);
			else
				snprintf(configfile, sizeof configfile, "%s" PATHSEP CONFIGFILENAME, userhome);

			// can't use sprintf since there is %u in savegamename
			strcatbf(savegamename, userhome, PATHSEP);
			strcatbf(liveeventbackup, userhome, PATHSEP);

			snprintf(luafiledir, sizeof luafiledir, "%s" PATHSEP "luafiles", userhome);
		}
		configfile[sizeof configfile - 1] = '\0';
		*/
		// }
		}

		// create addons dir
		//snprintf(addonsdir, sizeof addonsdir, "%s%s%s", srb2home, PATHSEP, "addons");
		//I_mkdir(addonsdir, 0755);

		// rand() needs seeded regardless of password
		//srand((unsigned int)time(NULL));
		//rand();
		//rand();
		//rand();

		/*
		if m_argv.m_check_parm(cmd_args::PASSWORD) && m_argv.m_is_next_parm() {
			//d_netcmd.d_set_password(m_get_next_parm());
		}
		*/

		// player setup menu colors must be initialized before
		// any wad file is added, as they may contain colors themselves
		//m_menu.m_init_player_setup_colors();

		cons_printf!("Z_Init(): Init zone memory allocation daemon. \n");
		z_zone.z_init();

		// Do this up here so that WADs loaded through the command line can use ExecCfg
		command.com_init();

		// add any files specified on the commandline with -file wadfile
		// to the wad list
		/*
		if !m_argv.m_get_url_protocol_arg() || m_argv.m_check_parm(cmd_args::CONNECT) && !m_argv.m_check_parm(cmd_args::SERVER) {
			if m_argv.m_check_parm(cmd_args::FILE) {
				// the parms after p are wadfile/lump names,
				// until end of parms or another - preceded parm
				while m_argv.m_is_next_parm() {
					let s: String = m_argv.m_get_next_parm();

					if !w_wad.w_verify_nmuslumps(s) {
						g_game.g_set_game_modified(true);
					}
					d_addfile(self.startuppwads, s);
				}
			}
		}
		*/

		// get map from parms
		/*
		if m_argv.m_check_parm(cmd_args::SERVER) || self.dedicated {
			d_clisrv.server = true;
			g_game.netgame = true;
		}*/

		// adapt tables to SRB2's needs, including extra slots for dehacked file support
		//P_PatchInfoTables();

		//initiate menu metada before SOCcing them
		//M_InitMenuPresTables();

		// init title screen display params
		/*(if m_argv.m_get_url_protocol_arg() || m_check_parm(cmd_args::CONNECT) {
			F_InitMenuPresValues();
		}
		*/

		//---------------------------------------------------- READY TIME
		// we need to check for dedicated before initialization of some subsystems
		cons_printf!("I_StartupTimer()...\n");
		//I_StartupTimer();

		// Make backups of some SOCcable tables.
		//P_BackupTables();

		// Setup character tables
		// Have to be done here before files are loaded
		//M_InitCharacterTables();

		//mainwads = 3; // doesn't include music.dta

		// load wad, including the main wad file
		cons_printf!("W_InitMultipleFiles(): Adding IWAD and main PWADs.\n");
		//W_InitMultipleFiles(startupwadfiles);
		//D_CleanFile(startupwadfiles);
		/*
	// Check MD5s of autoloaded files
	W_VerifyFileMD5(0, ASSET_HASH_SRB2_PK3); // srb2.pk3
	W_VerifyFileMD5(1, ASSET_HASH_ZONES_PK3); // zones.pk3
	W_VerifyFileMD5(2, ASSET_HASH_PLAYER_DTA); // player.dta
//#ifdef USE_PATCH_DTA
	W_VerifyFileMD5(3, ASSET_HASH_PATCH_PK3); // patch.pk3
//#endif
	// don't check music.dta because people like to modify it, and it doesn't matter if they do
	// ...except it does if they slip maps in there, and that's what W_VerifyNMUSlumps is for.
	*/

	//mainwadstally = packetsizetally; // technically not accurate atm, remember to port the two-stage -file process from kart in 2.2.x

	//cht_Init();

	//---------------------------------------------------- READY SCREEN
	// we need to check for dedicated before initialization of some subsystems

	cons_printf!("I_StartupGraphics()...\n");
	i_video.i_startup_graphics(
			self, command, i_system, mixer_sound, i_main,
			m_argv,
			// SDL
			sdl_context, video_subsystem, window_canvas, event_pump,
			sdlmain, screen);
//#ifdef HWRENDER
	// Lactozilla: Add every hardware mode CVAR and CCMD.
	// Has to be done before the configuration file loads,
	// but after the OpenGL library loads.
	//HWR_AddCommands();
//#endif

	//--------------------------------------------------------- CONSOLE
	// setup loading screen
	//SCR_Startup();

	}

	// Main game loop
	pub fn srb2_loop(&self,
		_console: Cons
		//d_clisrv: DClisrv
		) {
		//TODO: ACCEPTS a tic_t
		//let mut oldentertics: tic_t = 0
		//let mut entertic: tic_t = 0
		//let mut realtics: tic_t = 0
		// WHEREIS: INFTICS ?
		//let mut rendertimeout: tic_t = INFTICS;

		// TODO: ACCEPTS a lumpnum_t
		//let gstartuplumpnum: lumpnum_t;

		//if self.dedicated {
			// WHEREIS: server ?? => IS IN d_clisrv.c
		//	self.serv
		//}

		// Part of directdraw
		/*
		cons_printf!("I_StartupMouse()...\n");
		I_DoStartUpMouse();
		*/

		//oldentertics = 
		
	}

	pub fn d_home(&self, _m_argv: &MArgv) -> String {
		let mut _userhome: String = String::from("");
/*
		if m_argv.m_check_parm("-home") && m_argv.m_is_next_parm() {
			userhome = m_argv.m_get_next_parm();
		} else {
			if FIL_FileOk(CONFIGFILENAME) {
				self.usehome = false // let's NOT use home
			} else {
				userhome = //I_GetEnv("HOME"); //
			}
		}

		// todo
		if userhome = "" && self.usehome {

		}*/
		cons_printf!("TODO: make d_home() work!\n");
		if self.usehome {
			return _userhome;
		}
		std::string::String::from("")
	}
}