use crate::version;

use crate::cmd_args;

use crate::i_main::IMain;
use crate::console::Cons;
use crate::m_misc::Misc;
use crate::m_argv::MArgv;
use crate::g_game::Game;
use crate::sounds::Sounds;
use crate::dehacked::Dehacked;

// For SDL interface
use crate::sdl::i_system::ISystem;
use crate::sdl::i_video::IVideo;
use crate::sdl::mixer_sound::MixerSound;

pub struct DMain {
	// Version numbers for netplay 
	pub version: i32,
	pub subversion: i32,

	// platform independant focus loss
	pub window_notinfocus: bool, // UINT8

	///// DEMO LOOP
	pub startupwadfiles: Vec<char>, //startupwadfiles[MAX_WADFILES];
	pub startuppwads: Vec<char>, 	//*startuppwads[MAX_WADFILES];

	// started game with '-devparm'
	pub devparm: bool,
	pub singletics: bool,
	pub lastdraw: bool,

	// TODO: ACCEPTS a postimg_t
	//pub postimgtype: postimg_t,
	pub postimgparam: i32,
	//pub postimgtype2: postimg_t,
	pub postimgparam2: i32,

	// These variables are in effect
	// whether the respective sound system is disabled
	// or they're init'ed, but the player just toggled them
	pub midi_disabled: bool,
	pub sound_disabled: bool,
	pub digital_disabled: bool,

	pub advancedemo: bool,
	//ifdef DEBUGFILE
	pub debugload: i32,
	//endif

	pub numskincolors: u16, //UINT16
	// TODO: ACCEPTS a menucolor_t
	//pub menucolorhead: menucolor_t,
	//pub menucolortail: menucolor_t,

	pub savegamename: std::string::String,
	pub liveeventbackup: std::string::String,

	pub srb2home: std::string::String,
	pub srb2path: std::string::String,
	pub usehome: bool,
	pub pandf: std::string::String,
	pub addonsdir: Vec<char>, //addonsdir[MAX_WADPATH];
	
	//
	// EVENT HANDLING
	//
	// Events are asynchronous inputs generally generated by the game user.
	// Events can be discarded if no responder claims them
	// referenced from i_system.c for I_GetKey()
	// TODO: ACCEPTS a events_t
	//pub events: events_t, //events[MAXEVENTS];
	pub eventhead: i32,
	pub eventtail: i32,

	pub dedicated: bool,

	// modifier keys
	// Now handled in I_OsPolling
	pub shiftdown: u8, 	// 0x1 left, 0x2 right //UINT8
	pub ctrldown: u8, 	// 0x1 left, 0x2 right //UINT8
	pub altdown: u8, 	// 0x1 left, 0x2 right //UINT8
	pub capslock: bool,


	// wipegamestate can be set to -1 to force a wipe on the next draw
	// added comment : there is a wipe eatch change of the gamestate
	// TODO: ACCEPTS a gamestate_t
	//pub wipegamestate: gamestate_t,
	// -1: Default; 0-n: Wipe index; INT16_MAX: do not wipe
	pub wipetypepre: i16,
	pub wipetypepost: i16,

	// TODO: ACCEPTS a tic_t
	//pub rendergame: tic_t,
}
impl DMain {
	pub fn new() -> Self {
		DMain {
			version: 0, 	// todo: calculate
			subversion: 0,	// todo: calculate
			window_notinfocus: false,
			startupwadfiles: Vec::new(),
			startuppwads: Vec::new(),
			devparm: false, // todo: calculate
			singletics: false,
			lastdraw: false,
			postimgparam: 0,
			postimgparam2: 0,
			midi_disabled: false,
			sound_disabled: false,
			digital_disabled: false,
			advancedemo: false,
			debugload: 0,
			numskincolors: 0,
			savegamename: std::string::String::from(""),
			liveeventbackup: std::string::String::from(""),
			srb2home: std::string::String::from("."),
			srb2path: std::string::String::from("."),
			usehome: true,
			pandf: std::string::String::from("%s%s")/*%sPATHSEP%s*/,
			addonsdir: Vec::new(),
			eventhead: 0,
			eventtail: 0,
			dedicated: false,
			shiftdown: 0,
			ctrldown: 0,
			altdown: 0,
			capslock: false,
			wipetypepre: -1,
			wipetypepost: -1,
		}
	}

	pub fn convert_version_nums(&mut self) {
		let _major: i32;
		let _minor: i32;

		//sscanf(SRB2VERSION, "%d.%d.%d", &major, &minor, &SUBVERSION);

		// TODO: use sscanf esque method to acquire major and minor versions
		// major
		self.version = version::SRB2VERSION.chars().nth(0).unwrap().to_digit(10).unwrap() as i32;
		// minor
		self.subversion = version::SRB2VERSION.chars().nth(2).unwrap().to_digit(10).unwrap() as i32;
	}

	// Do preparations
	pub fn srb2_main(&mut self, 
		_console: Cons,
		m_misc: Misc,
		mut m_argv: MArgv,
		mut g_game: Game,
		sounds: Sounds,
		dehacked: Dehacked,
		mut i_system: ISystem,
		i_video: IVideo,
		mixer_sound: MixerSound,
		i_main: &mut IMain
		) {
		let _p: i32;
		let _pstartmap: i32 = 1;
		let _autostart: bool = false;

		// Break version string into version numbers for netplay
		self.convert_version_nums();

		// todo: something is probably wrong about this?
		// Print GPL notice for our console users (Linux)
		cons_printf!(
		"\n\nSonic Robo Blast 2\n",
		"Copyright (C) 1998-2020 by Sonic Team Junior\n\n",
		"This program comes with ABSOLUTELY NO WARRANTY.\n\n",
		"This is free software, and you are welcome to redistribute it\n",
		"and/or modify it under the terms of the GNU General Public License\n",
		"as published by the Free Software Foundation; either version 2 of\n",
		"the License, or (at your option) any later version.\n",
		"See the 'LICENSE.txt' file for details.\n\n",
		"Sonic the Hedgehog and related characters are trademarks of SEGA.\n",
		"We do not claim ownership of SEGA's intellectual property used\n",
		"in this program.\n\n");

		// initialise locale code
		m_misc.m_startup_locale();

		// get parameters from a response file (eg: srb2 @parms.txt)
		m_argv.m_find_response_file();

		// MAINCFG is now taken care of where "OBJCTCFG" is handled
		g_game.g_load_game_settings(sounds);

		// Test Dehacked Lists
		dehacked.deh_check();

		// Netgame URL special case: change working dir to EXE folder.
		//ChangeDirForUrlHandler()

		// identify the main IWAD file to use
		//self.identify_version();

		self.devparm = m_argv.m_check_parm(cmd_args::DEBUG) != 0;
		self.dedicated = m_argv.m_check_parm(cmd_args::DEDICATED) != 0;

		if self.devparm {
			//CONS_Printf(M_GetText("Development mode ON.\n"));
			cons_printf!("Development mode ON.\n");
		}

		// default savegame
		//strcpy(savegamename, SAVEGAMENAME"%u.ssg");
		//strcpy(liveeventbackup, "live"SAVEGAMENAME".bkp"); // intentionally not ending with .ssg

		// wat
		// {
			let userhome: String = self.d_home(m_argv);

			if userhome == "".to_string() {
				// unfortunately variadic functions are not a thing in Rust
				// therefore we'll use an array instead
				i_system.i_error(&["Please set $HOME to your home directory\n"], i_video, mixer_sound, i_main);
			}

		// }

	}

	// Main game loop
	pub fn srb2_loop(&self,
		_console: Cons
		//d_clisrv: DClisrv
		) {
		//TODO: ACCEPTS a tic_t
		//let mut oldentertics: tic_t = 0
		//let mut entertic: tic_t = 0
		//let mut realtics: tic_t = 0
		// WHEREIS: INFTICS ?
		//let mut rendertimeout: tic_t = INFTICS;

		// TODO: ACCEPTS a lumpnum_t
		//let gstartuplumpnum: lumpnum_t;

		//if self.dedicated {
			// WHEREIS: server ?? => IS IN d_clisrv.c
		//	self.serv
		//}

		// Part of directdraw
		/*
		cons_printf!("I_StartupMouse()...\n");
		I_DoStartUpMouse();
		*/

		//oldentertics = 
		
	}

	pub fn d_home(&self, _m_argv: MArgv) -> String {
		let mut _userhome: String = String::from("");
/*
		if m_argv.m_check_parm("-home") && m_argv.m_is_next_parm() {
			userhome = m_argv.m_get_next_parm();
		} else {
			if FIL_FileOk(CONFIGFILENAME) {
				self.usehome = false // let's NOT use home
			} else {
				userhome = //I_GetEnv("HOME"); //
			}
		}

		// todo
		if userhome = "" && self.usehome {

		}*/
		cons_printf!("TODO: make d_home() work!\n");
		if self.usehome {
			return _userhome;
		}
		std::string::String::from("")
	}
}